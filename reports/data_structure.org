
#+TITLE: Data Structure and Travel Algorithm
#+AUTHOR: Gun Woo Park

* Preface
This documentation is related with the basic data structure and travel algorithm for the given graph structure in order to identify percolated structure. 

* Multi-dimensional Array
For compatibility and convenience, the multi-dimensional arrays are expressed by one-dimensional array by index mapping function. To be specific, the given N by M 2-dimensional array may have the form of table [[tab:basic_2d_array]], which is possibly mapped to table [[tab:map_to_1d_from_2d]]. The advantage for this expression can be thought as two parts: coding interface can be united and we can use several compression techniques such as lower occupation for symmetric matrix. There are various numerical packages have been used this way: BLAS, LAPACK, GSL, and so on.


#+NAME: tab:basic_2d_array
#+ATTR_HTML: :rules all :frame border :center t
#+CAPTION: Example for typical 2-dimensional array
| <c>   | <c>      | <c>      | <c>      | <c>      | <c>       |
| index | 0        | 1        | 2        | $\cdots$ | M         |
|-------+----------+----------+----------+----------+-----------|
| 0     | val(0,0) | val(0,1) | val(0,2) |          | val(0, M) |
| 1     | val(1,0) | val(1,1) | val(1,2) |          | val(1, M) |
|       |          | $\vdots$ |          | $\ddots$ |           |
| N     | val(N,0) | val(N,1) | val(N,2) |          | val(N,M)  |

#+NAME: tab:map_to_1d_from_2d
#+ATTR_HTML: :rules all :frame border
#+CAPTION: Example for mapping to 1-dimensional array from 2-dimensional array.
| index  | 0        | 1        | $\cdots$ | M        | M+1      | $\cdots$ | NM       |
|--------+----------+----------+----------+----------+----------+----------+----------|
| <c>    | <c>      | <c>      | <c>      | <c>      | <c>      | <c>      | <c>      |
| coord. | (0,0)    | (0,1)    | $\cdots$ | (0,M)    | (1,0)    | $\cdots$ | (N,M)    |
|--------+----------+----------+----------+----------+----------+----------+----------|
| val.   | val(0,0) | val(0,1) | $\cdots$ | val(0,M) | val(1,M) | $\cdots$ | val(N,M) |



* Adjacency Matrix and List
Consider the given association information, we can easily express the information using adjacency matrix:
\begin{equation}
\mathbf{C}_m = \left[\mathscr{C}_{ij}\right],
\end{equation}
where $\mathscr{C}_{ij}$ is number of associations for the pair of i- and j-th particles.
The expression is quite simple and it contains all the existing information. In the case of time and space complex, however, the adjacency matrix is not so much efficiency if the matrix is sparse, which needed a lot of zeros inside matrix and a lot of zero identification that overhead the total time computation for identification of association. On this regards, adjacency list is more efficiency:
\begin{equation}
\mathbf{C}_l = \left[\mathscr{I}_{i}(j)\right],
\end{equation}
where i denote the index for subject particle, j denote index for columns, and $\mathscr{I}_{i}(j)$ is the index that is j-th connection to the i-th particle. 
For instance, consider the given network has the form of figure [[fig:ex_graph_association]], then the adjacency matrix becomes table [[tab:ex_adjacency_matrix]] and the adjacency list is expressed in table [[tab:ex_adjacency_list]]. Using adjacency list, the weight for the bridge should be stored in separated array.

#+NAME: fig:ex_graph_association
#+HTML_ATTR: :width 640px
#+CAPTION: Example for association maps. It can be regarded as undirected graph since there is no directional information for the association (edge as CS notation) between particles (vortex as CS notation).
[[file:data_structure/ex_graph_association.png]]


#+NAME: tab:ex_adjacency_matrix
#+ATTR_HTML: :rules all :frame border
#+CAPTION: Example of adjacency matrix for figure [[fig:ex_graph_association]].
|   |     1 |     2 |     3 |     4 |     5 |     6 |
|---+-------+-------+-------+-------+-------+-------|
| 1 | $N_1$ |     1 |     5 |     0 |     0 |     0 |
|---+-------+-------+-------+-------+-------+-------|
| 2 |     1 | $N_2$ |     1 |     0 |     0 |     0 |
|---+-------+-------+-------+-------+-------+-------|
| 3 |     5 |     1 | $N_3$ |     0 |     0 |     1 |
|---+-------+-------+-------+-------+-------+-------|
| 4 |     0 |     0 |     0 | $N_4$ |     1 |     0 |
|---+-------+-------+-------+-------+-------+-------|
| 5 |     0 |     0 |     0 |     1 | $N_5$ |     0 |
|---+-------+-------+-------+-------+-------+-------|
| 6 |     0 |     0 |     1 |     0 |     0 | $N_6$ |

#+NAME: tab:ex_adjacency_list
#+ATTR_HTML: :rules all :frame border
#+CAPTION: Example of adjacency list for figure [[fig:ex_graph_association]].
| bead | 0 | 1 | 2 |
|------+---+---+---|
| 1    | 2 | 3 | 0 |
| 2    | 1 | 3 | 0 |
| 3    | 1 | 2 | 6 |
| 4    | 5 | 0 | 0 |
| 5    | 4 | 0 | 0 |
| 6    | 3 | 0 | 0 |


* Identification for Percolation
The percolation for one spatial dimension can be solved by travel algorithm based on the association maps. Since our system has restricted number of beads, the travel algorithm is not too time consuming if it is occasionally turned on to check the status of percolation. That means we can avoid the heuristic algorithm that cannot guarantee to find all the pathway, but using deterministic algorithm to identify the dimensional percolation. 

The idea of percolation test is simple: travel through all the bridge that connected on subject particle, then identify the travel of bridge goes beyond box based on axis. Hence, this section is composed of topics (i) how to identify travel beyond box, (ii) how to travel from subject particle.

# The core idea at this moment is travel for the given graph structure. During travel for the bead (vortex) based on the connections (edge), percolation will be checked based on the attached wall. Each spatial dimension, two ending of box is the basic for the percolation, once the travel go through the wall, it is recorded based on the specified connection group. As starting point of view, depth-first search (DFS) can be used for this approach, but there are various algorithm that can travel for the graph structure. Notice that such a different algorithm making different spanning tree from the graph (since spanning tree of graph is not unique) which means the time complex may vary depends on the algorithm. The given adjacency list can be regarded as hash table which means the application for the various algorithm is not so much difficulty and time consuming. As testing purpose, the network is given by figure [[fig:ex_graph_DFS]].

** Travel Beyond Box Boundary
*** Minimum Image Convention
Before going further, it is better to mention that the minimum distance between pair of particles is using component-wise minimization:
#+NAME: eq:component_wise_minimum_distance
\begin{equation}
r^{(m)}_k(\mathbf{r}_i, \mathbf{r}_j) = \min\left\{x_k(\mathbf{r}_j) - \left(L_D\mathscr{S} + x_k(\mathbf{r}_i)\right)\right\},
\end{equation}
where $k$ denote the k-th spatial dimension and $L_D$ is box dimension and the shift set is given by $\mathscr{S} = \{-1, 0, +1\}$,
which implies the relative vector of minimum distance from $\mathbf{r}_j$ to $\mathbf{r}_i$ is
\begin{equation}
Crd_{\varepsilon}\left(\mathbf{r}^{(m)}(\mathbf{r}_i, \mathbf{r}_j)\right) = [r_1(\mathbf{r}_i, \mathbf{r}_j), \cdots, r_{N_D}(\mathbf{r}_i, \mathbf{r}_j)]^T,
\end{equation}
where $\varepsilon$ is given basis set. Minimum distance is simply given by Euclidean norm of this relative vector of minimum distance.

#+NAME: fig:comp_min_dist_rel_vector
#+HTML_ATTR: :width 640px
#+CAPTION: Component-wise minimum distance relative vector
[[file:data_structure/comp_minimum_distance.png]]

Let assume that we have 3 particles and the subject particle is zero, which depicted figure [[fig:comp_min_dist_rel_vector]]. Let subject particle is 0 and try to find the minimum distance between 0 and 2. Then, we have to count the images of 2 which can be identified by left and right, no matter the axis. This is exactly the same meaning with equation [[eq:component_wise_minimum_distance]] since
\begin{equation}
d^{(m)}_{ij} = \left|\mathbf{r}^{(m)}(\mathbf{r}_i, \mathbf{r}_j)\right|_2 = \sqrt{\sum_{k=1}^{N_d} (r^{(m)}_k(\mathbf{r}_i, \mathbf{r}_j))^2}
\end{equation}
becomes minimum when each $r^{(m)}_k$ is minimum. Notice that this happens because of orthonormal basis. /For general basis set, it is of importance that we have to measure component based on reciprocal base vector, which will be involved when the system is experienced shear./ 
# The code [[componentwise_minimum_distance_cpp]] is written by c/c++ based on this concept.

*** Identifier for Boundary Travels and Percolation
# For convenience, periodicity will not accounted on this section, which will be covered in later sections. The association information is already described based on adjacency list that is kind of form for hash table. Code [[code:DFS_graph]] is travel algorithm that based on the given root index and try to find all the connection information that will be saved in the stack queue of the argument. The code successfully returns connection information and the travel iteration was 22.
# By using the shift set $\mathscr{S}$, we can identify the given association travels beyond the box because 
# The identification for percolation is checked through the minimum image convention. 
# Internally, the minimum image convention is checked based on the box shift array [-1, 0, 1] with box dimension, $L_D$, as multiplier. 
# The reason of this simplified shift array is the PBC box maps the minimum image that is independent between spatial dimensions, xyz. By independent, we can define left and right (the real left and right side is not important in this case) of travel beyond current box with shift value -1 and +1, respectively. 
To travel via given bridge from i-th to j-th particle, we are counting the shift factor for each dimensionality. If all the shift factors are zero, it means the travel will happen inside of box. If k-th dimension has left (-1) or right (+1) shift factor, then the given travel go beyond left or right boundary of k-th axis, respectively. In one cluster but might be different pairs, if both of left shift and right boundary travels happened, we can think that this cluster percolate through k-th dimension. 

** Travel Algorithm
*** Travel for Vertex: Measuring Cluster Size Distribution
For terminology, let cluster as the group of particles that is connected. The size of cluster is defined by number of particles on the subjected cluster, then we can measure cluster size distribution for given system. To say this one in the first section of travel algorithm is it is just based on travel algorithm for vertex.

As briefly described in previously, the given associated network has the same structure with the undirected graph which is composed of vertex (particles in this case) and edge (association in this case). Undirected means that bridge chain is symmetric under the index of pair of particles, $\mathbf{r}_{ij} = \mathbf{r}_{ji}$, when it is in PBC box. Extracting association network information is basically the same with travel the given network system, which means we can apply general travel algorithm for graph such as depth-first search (DFS) and breadth-first search (BFS). The efficiency of travel algorithm can be analyzed by spanning tree of given graph, which is one way to express graph into tree. Simply say that for given root index, we travel for the spanning tree which generated from the given graph using DFS. 
# In principle, both of DFS and BFS has the same time complexity, $\mathscr{O}(|E| + |V|)$, where E represent edges and V represent vertex. The algorithm on here is used DFS, but BFS will show the same results as well. 

When we travel vertex no matter the path of edges by the general travel algorithm, all the particle of the given cluster is visited and we can record the given information. By adjusting root index, we can generate all the cluster information for the system, which is the key to measure cluster size distribution.

*** Travels for Edges: Identify Travels Beyond PBC Box
Travel for vertex means we visit all the particles that connected with the given root particle, but it does not guarantee that visiting all the bridges. The percolation identification depends on the bridges, not about particles itself, which means we need to modify travel algorithm from vertex point of view to edge point of view. Of course, there are various way to travel edges, but we need only information of edge not about real travels. Hence, the algorithm is slightly modified when subjected travel directed to already visited particle, just identify the travel go beyond box, then record it when it is so. The algorithm is not violated from this identification since travel for vertex will not miss all the bridges.

*** Travels inside PBC Box
As already mentioned in above, the travel is only allowed inside box and whenever travel is experienced beyond box, travel is canceled and it will be recorded for percolation identification. By this assumption, we cannot miss all the percolation happens inside box. When percolation happens including its image of subjected box, it cannot be captured by introduced method.
To be specific, consider the networks in figure [[fig:percolation_beyond_box]] shows that different percolation scheme. However, the percolation through x axis in the (b) of figure [[fig:percolation_beyond_box]] cannot be captured by given scheme since the percolation line through the boundary of subjected box. For relatively large 3-dimensional box, the situation is not so common, which is the reason to use introduced identification procedure. 

#+NAME: fig:percolation_beyond_box
#+ATTR_HTML: :width 860px
#+CAPTION: Two dinsintuishable 2-dimensional cluster system. Left figure (a) represent percolation happens along y axis while no percolation along x axis. Right figure (b) represent the percolation happens both of x and y axis, but x percolation line beyond the subjected box. The thick red line represent isolation while the thick blue line represent percolation line along x axis.
[[file:data_structure/ex_percolation_identification.png]]

*** Allowing Travel Beyond Boundary of Box
It might be more general way to allow travel beyond boundary of box. At this moment, there are several difficulties to allow such a travels. The most importance question is /how to identify percolation/.

Allowing one more image of the subjected box is a key to identify percolation. During travels, we have to record all the parity of the travel identifier since it is a key of image. Sum of all travel identifier for a given axis, say image identifier, should not lower than -1 and higher than +1, which means only direct image of subjected box will be accounted. It is of importance to distinguish between particles in different box even if they have the same index number, which can be achieved using image identifier:
\begin{equation}
I^{k} = \sum_{i=1}^{N_{tb}} s^{k}_i,
\end{equation}
where $N_{tb}$ is number of travel beyond boundary, k denote k-th spatial dimension and $s^k_i \in \mathscr{S}$. It is quite simple that the image identifier, $I^{k}$ can be any value of $\mathscr{S}=\{-1, 0, +1\}$, which direct the current travel happens in the left, center, or right side of the box, respectively. Therefore, /recorded shift factor is not the instance shift factor but sum of all instance shift factors./ Note that the travel to image particle is allowed even if its original particle in current PBC box is visited status. Once the travel is finished, all the particles in its direct image have been visited status and we have to make sure the all the edges are accounted for identification of travel. 

The identifier for this case is the same with travel identifier inside box: one cluster for k-th axis shows both of left and right imaginary shift factor, this is percolated. We do not need to travel further from direct image of current box because of periodicity. 

# We can identify between root particle and its imaginary particle with the $I^k$. 



# The answer on here is to measure travel distance from its origin. Allowing travel of its image might be a key. 

# For simplification, consider the one-dimensional travel 

# The answer on here is to use even or odd parity for the cluster. For simplification, consider the one-dimensional travel like the depicted in the figure [[fig:comp_min_dist_rel_vector]]. For given cluster, we have visited all the particles that connected to root particle. We can count the number of boundary travel whether it is left or right. 

** Python Code for Measuring Cluster Size and Percolation Identification
There are various way to develop DFS algorithm for tree structure in general way. It is quite simple to use recursive form since DFS is using call stack. With given size of cluster, however, the recursive call is limited by system for safety reason, and have potential overhead because of calling functions typically taking time. On this regards, the code is developed by iterative manner with some set of if-phrase in order to identify edge travels. The code is described on code [[code:DFS_percolation]] written by python. The root index will be given by the argument index (default is zero). When we need to travel all the sub-graph of given graph (existing several clusters), we can iterate root index from zero to number of particles, then we can extract distinguishable clusters, which is the way to measure cluster size distribution.




* Appendix
** Graph
Mathematically, a graph is an ordered pair $G = (V, E)$ where a set $V$ of vertices and a set $E$ of edges. 

For instance, we have vertices and edges for figure [[fig:ex_graph_DFS]] as 
\begin{align}
V &= \{0, 1, 2, 3, 4, 5\}\\
E &= \{(0, 1), (0, 3), (1, 2), (2, 4), (2, 5), (3, 4), (4, 5)\},
\end{align}
which in consequence $V$ is set of all the index for particles and $E$ is set of all pairs of index for bridges. It is of importance that the identification of percolation is not necessary to count weight on the bridge, i.e., number of connections for the same bridge, so we do not need count all the weight array on this graph analysis. In addition, the given graph is undirected since all the element for $E$ is symmetric under the pair index: $(i, j) = (j, i)$. 

#+NAME: fig:ex_graph_DFS
#+HTML_ATTR: :wdith 640px
#+CAPTION: Example for association maps. This example will be used DFS testing and the starting index  changed to 0 from 1 for compatibility with the code infrastructure. Therefore, index zero indicate the zero-th particle and -1 indicate there is no association.
[[file:data_structure/ex_graph_DFS.png]]

** Tree and Spanning Tree
Tree is linearized graph, which means graph without any circle of bridges. For given network structure is not tree because of association can happens to make loop. To understand tree structure, however, is of importance since the algorithms to travel graph is based on the tree. Basically, the graph cannot be merged to tree structure, but if we ignore loop bridges, we can span tree structure from given graph which is called /spanning tree/. In consequence of linearization, the spanning tree is not unique that depends on the algorithms to travel. 

To be specific, for graph depicted in figure [[fig:ex_graph_DFS]], if we apply DFS algorithm, the spanning tree has the form of figure [[fig:spanning_tree_DFS]]. Here, the 0-th particle is selected as root, and the rank of child is represented by depth from root. If we use BFS algorithm, the spanning tree has different form like figure [[fig:spanning_tree_BFS]]. The travel sequence for DFS becomes $0\to 1\to 2\to 4\to 3\to 5$ while BFS becomes $0\to 1\to 3\to 2\to 4\to 5$. In principle, the spanning tree is not necessary to generate but it is good way to understand the properties of given graph. Since DFS is used as default, this article only contains details about DFS. The adjacency list for the given graph is described in table [[tab:adjacency_list_ex]].

#+NAME: tab:adjacency_list_ex
#+CAPTION: Adjacency list for the given graph, figure [[fig:ex_graph_DFS]]
|   | 1 | 2 |  3 |
|---+---+---+----|
| 0 | 1 | 3 | -1 |
| 1 | 0 | 2 | -1 |
| 2 | 1 | 4 |  5 |
| 3 | 0 | 4 | -1 |
| 4 | 2 | 3 |  5 |
| 5 | 2 | 4 | -1 |
|---+---+---+----|



#+NAME: fig:spanning_tree_DFS
#+HTML_ATTR: :width 640px
#+CAPTION: DFS spanning tree for graph depicted in figure [[fig:ex_graph_DFS]].
[[file:data_structure/spanning_tree_DFS.png]]

#+NAME: fig:spanning_tree_BFS
#+HTML_ATTR: :with 640px
#+CAPTION: BFS spanning tree for graph depicted in figure [[fig:ex_graph_DFS]].
[[file:data_structure/spanning_tree_BFS.png]]


* Figures
** Example for Association Graph

** Example for DFS test

* Codes
** Component-wise Minimum Distance
#+NAME: componentwise_minimum_distance_cpp
#+BEGIN_SRC c++ -n -i
double get_minimum_image_k_from_x(double x, double k, double dimension)
{
    double kd[3] = {k-dimension - x, k - x, k + dimension - x};
    double re = [get_index_minimum_abs(kd, 3)] + x;
    return re;
}
#+END_SRC
** DFS for identification of percolation
#+NAME: code:DFS_percolation
#+BEGIN_SRC python -n -i
def check_travel_beyond_box(pos, index, target, Ld):
    Nd = shape(pos)[1]
    for k in range(Nd):
        if (ident_minimum_distance_k_from_x(pos[index, k], pos[target, k], Ld) != 0):
            return 1
    return 0

def ident_minimum_distance_k_from_x(x, k, box_dimension):
    kd = asarray([k-box_dimension - x, k-x, k+box_dimension-x])
    return argmin(abs(kd)) - 1 # will return [-1, 0, +1]

def ident_over(hash, index, order_count):
    N_cols = shape(hash)[1]
    if order_count >= N_cols:
        return 1
    if int(hash[index, order_count]) is -1:
        return 1
    return 0

def cluster_edge_DFS_travel_restricted_box_iter(hash, pos, Ld, record_component, index=0, order_count=1, cnt=0, IDPC=[], IDPI=[], stack=[], stack_order=[]):
    cnt = 0; const_new_order_count = 1 # initialisation variables
    N_cols = shape(hash)[1] # limitation for the hash tables
    stack.append(int(index)); stack_order.append(order_count) # initial stacking
    while(size(stack) > 0): # will false when size(stack) is 0 if it is not initial step
        cnt += 1 # temporal counting 
        ident_over_cols = ident_over(hash, index, order_count)
        if ident_over_cols: # in the case that the hash[index, order_count] reaching end (-1 or order_count is over)
            stack = stack[:-1]; stack_order = stack_order[:-1]
            if (size(stack) > 0):
                index = stack[-1]; order_count = stack_order[-1] + 1
        else: # in the case that the hash[index, order_count] is properly defined
            target = hash[index, order_count]
            travel_beyond_box = check_travel_beyond_box(pos, index, target, Ld)
            if (target in record_component) or travel_beyond_box: # when target is in stack stack or travel beyond box boundary
                if travel_beyond_box: 
                    for id in range(shape(pos[index, :])[0]):
                        ident_IDP = ident_minimum_distance_k_from_x(pos[index, id], pos[target, id], Ld)
                        if (int(ident_IDP) is not 0) and ([index, target] not in IDPI):
                            IDPC.append([id, ident_IDP])
                            IDPI.append([index, target])
                # when particle is duplicated or travel_beyond_box
                index = index; order_count = order_count + 1;

                # this means it inherit the exist index for bead but increase order_count
                # note that the target for next step is given by hash[index, order_count]
            else: # when the target will stack
                record_component.append(int(target))
                stack.append(int(target)); stack_order.append(order_count) # record element and its order for stack
                index = target; order_count = const_new_order_count; # depth first search
    return size(stack)
#+END_SRC
